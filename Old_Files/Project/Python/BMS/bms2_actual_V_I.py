# -*- coding: utf-8 -*-
"""BMS1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18On6oCfUTcXebasGceT3RL1o8CgoNWZ-

**Model EKF : **
https://home.wlu.edu/~levys/kalman_tutorial/

code
"""

import numpy as np
import csv
#import matplotlib.pyplot as plt
from numpy.linalg import inv
import paho.mqtt.publish as publish

import serial
import time


def statediff (x,u):
  #separate terms from the state vector and input vector
  soh = x[0]
  soc = x[1]
  vc = x[2]
  current = float(u)
  #print('\n current Sttediff ', current, type(current))
  #Get state-dependent parameters. Rth & Cth
  r2= 2.5968*(soc**4)-3.5211*(soc**3)+ 0*(soc**2)+1.4757*(soc)-0.3317 #as per the matlab code
  #r2 = 10.6048 * soc **4 - 15.1475 * soc ** 3 + 0 * soc ** 2 + 7.1826 * soc - 2.0363 # Rth float
  c2=200000
  #c2 = 90000 #constant
  # Capacity changes with soh
  
  #~~~calculating capacity~~~
  CAPACITY_NEW =20;
  CAPACITY_OLD_PERCENT =80
  
  alpha =  CAPACITY_OLD_PERCENT /100
  beta = 1 - alpha
  capacity = CAPACITY_NEW * (alpha + beta*soh)
  
  #calculate the rate of change of capacity
  #dcapacity = derivStruct();
  #dcapacity.dsoh = CAPACITY_NEW * beta ;
  lifetime = 2000; #const depend on battery
  
  #Implement state update equation
  dsoh = -abs(current) / (2*lifetime*capacity*3600)
  dsoc = - current / (capacity*3600)
  dvc = (-vc) /(c2*r2) + (current/c2)
  #dtemp = 0
  
  arrayOut = np.array([dsoh,dsoc,dvc])
  #print('\n arrayOut Sttediff ', arrayOut, arrayOut.shape, type(arrayOut) )
  
  return arrayOut

#initial values assigned
I0 = 0 #Input current
soh = 0.8 
soc = 1 #Assumed full charged

time = []
SOH = []
SOC = []
Vm = []
Vp = []
Im = []
  
sampleTime =0.2

# 3 states declaration
soc1 = soc
soh1 = soh
Vth1 = 0

#Process Error Co-variance Matrix (Q) E[XX^T]
Qk = np.array([[0.05 , 0 , 0],[0, 0.04, 0],[ 0, 0, 1]])

#print('Qk',Qk,Qk.shape)

#Initial Process Error Co-variance Matrix (Pkint = Qkint)
Pkint = np.array([[0.1,0,0],[0,0.1,0],[0,0,0.1]])
#print('\n Pkint',Pkint,Pkint.shape)
Pkin = Pkint

#Measurement Error Co-variance Matrix (R)
R = np.array([0.5]) #(1,)

ser1 = serial.Serial("/dev/ttyACM0", baudrate =9600)
ser1.flush()

t=0

while True :

    if (t == 100) :
      break
   
    
    vol = ser1.readline()
    dec = vol.decode()
    #print (dec)
    #print('done2')
    splitV_I= dec.split(' ')
    #print(splitV_I[2])#voltage
    #print(splitV_I[6])#current
    v = float(splitV_I[2])#voltage
    i = float(splitV_I[6])#current    
    print(v)#voltage
    print(i)#current
    #print(type(v),type(i))

    t = t+1
    I0 = i
    V0 = v
    print(t)
    #print('\n I0',type(I0)) #str
    #time.append(t)
    #current.append(current)

    r2= 2.5968*(soc**4)-3.5211*(soc**3)+ 0*(soc**2)+1.4757*(soc)-0.3317  # Rth float
    #print('\n r2', type(r2))
    #print(float(I)) #print row wise float current value

    #Vth calculation
    Vth = float(I0) * r2
    Vth1 = Vth

      # ~~~~ Neglecting errors ~~~~ 
    r2y = 2.5968*(soc**4)-3.5211*(soc**3)+ 0*(soc**2)+1.4757*(soc)-0.3317 # Rth float
    '''
    print('\n soc1',soc1)
    print('\n soh1',soh1)
    print('\n Vth1',Vth1)
    '''
    
    #Vth calculation
    Vth1 = float(I0) * r2y
    #print('\n Vth1 = I0 *r2y', Vth1)

    y = np.array([[soh1],[soc1],[Vth1]]) # (3,1)
    #print('\n y ', y, y.shape)

    yPredict = y + (statediff(y,float(I0))*0.2) #considering no errors writing coulomb counting (3,1)
    #print('\n yPredict ',yPredict, yPredict.shape,type(yPredict))

    soh1 = yPredict[0,0]
    soc1 = yPredict[1,0]
    Vth1 = yPredict[2,0]
    #print('\n yPredict[0] yPredict[1] yPredict[2] typeSOH ',yPredict[0],yPredict[1],yPredict[2], type(yPredict[0]), type(soh1))

    Voc1=9.8958*(soc1)**4-19.3750*(soc1)**3+15.1042*(soc1)**2-3.9250*(soc1)+24.06

    r01 = 0.0002
    voltage=float(V0)

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    #current state of the battery
    x =np.array([[soh],[soc],[Vth]]) #(3,1)
    #print('\n x ', x, x.shape)

    #find the prediction of x
    xPredict= x + (statediff(x,float(I0))*sampleTime) #(3,1)
    #print('\n xPredict ',xPredict, xPredict.shape,type(xPredict))

    soh= xPredict[0,0]
    soc= xPredict[1,0]
    Vth= xPredict[2,0]
    #print('\n xPredict[0] xPredict[1] xPredict[2] typeSOH ',xPredict[0],xPredict[1],xPredict[2], type(xPredict[0]), type(soh))


    #calculation of thevenin model parameters
    r0 = 0.0002
    c2 = 200000
    Voc=9.8958*(soc**4)-19.3750*(soc**3)+15.1042*(soc**2)-3.9250*(soc)+24.06

    #~~~~~~~~~~~~~~~~
    #predicted output
    HKPredict=Voc-Vth-float(I0)*r0 # Vout predict
    #print('\n HKPredict',HKPredict, type(HKPredict))

    #jacobian of state functions
    Fk = np.array([[1,0,0],[ 0,1,0], [0,0,(1/(r2*c2))]]) #constant here (3,3)
    #print('\n Fk ', Fk, Fk.shape, type(Fk))

    #jacobian of output function
    HK=np.array([[0 ,0, -1]]) #need 2 brackets to (1,3)
    #print('\n HK ', HK, HK.shape, type(HK))
    HKT=HK.T
    #print('\n HKT ', HKT, HKT.shape, type(HKT))

    FkT=Fk.T #FkT=Fk.transpose()
    Pk=np.dot(Fk,np.dot(Pkin,FkT))+Qk
    '''
    print('\n Pk ', Pk, Pk.shape, type(Pk))
    print('\n check ' ,np.dot(Fk,np.dot(Pkin,FkT)))
    print('\n kui ' ,Qk)  
    print('\n check2 ' ,np.dot(Fk,np.dot(Pkin,FkT))+Qk)
    '''
    #kalman gain
    Gk=np.dot(Pk,np.dot(HKT,inv(np.dot(HK,np.dot(Pk,HKT))+R)));
    #print('\n Gk ', Gk, Gk.shape, type(Gk)) #(3,1)

    xest=xPredict+ (Gk*(voltage-HKPredict)); #equation Dimension Issue corrected
    #print('\n xest ', xest, xest.shape, type(xest)) #(3,1)
    #print('\n np.dot(Gk,(voltage-HKPredict ', np.dot(Gk,(voltage-HKPredict))) #(3,1)


    PK=np.dot((np.identity(3)-(np.dot(Gk,HK))),Pk); #equation

    #next loop update
    soh=xest[0,0];
    soc=xest[1,0];
    Vth=xest[2,0];

    vest=Voc-Vth-float(I0)*r0; #not necessary seems
    Qk = Pkin
    Pkin = PK
    
    time.append(float(t))
    Vm.append(float(V0)) 
    Im.append(float(I0))
    SOH.append(soh)
    SOC.append(soc)
    Vp.append(HKPredict)
    
    publish.single("93/bms/v2/soc",soc*100,hostname = "test.mosquitto.org")
    print("SOC - PUBLISHED")
    publish.single("93/bms/v2/soh",soh*100,hostname = "test.mosquitto.org")
    print("SOH - PUBLISHED")

    
    
print(time)
print('Vm Measured Voltage',Vm)
print('Im Measured Current',Im)
print('soh',SOH)
print('soc',SOC)
print('Vp Predicted Voltage',Vp)

'''
plt.figure(figsize = (30,5))
plt.plot(time,Im,'ko')
plt.title('Current Input',fontsize = 40)
plt.xticks(fontsize = 40)
plt.yticks(fontsize = 40)
plt.xlabel('Time Step',fontsize = 40)
plt.ylabel('Current (A)' , fontsize = 40)

plt.figure(figsize = (30,5))
plt.plot(time,Vp,'bo')
plt.title('Predicted Voltage',fontsize = 40)
plt.xticks(fontsize = 40)
plt.yticks(fontsize = 40)
plt.xlabel('Time Step',fontsize = 40)
plt.ylabel('Voltage (V)' , fontsize = 40)

plt.figure(figsize = (30,5))
plt.plot(time,Vm,'go')
plt.title('Measured Voltage',fontsize = 40)
plt.xticks(fontsize = 40)
plt.yticks(fontsize = 40)
plt.xlabel('Time Step',fontsize = 40)
plt.ylabel('Voltage (V)' , fontsize = 40)

plt.figure(figsize = (30,5))
plt.plot(time,SOC,'ro')
plt.title('SOC',fontsize = 40)
plt.xticks(fontsize = 40)
plt.yticks(fontsize = 40)
plt.xlabel('Time Step',fontsize = 40)
plt.ylabel('SOC' , fontsize = 40)


plt.figure(figsize = (30,5))
plt.plot(time,SOH,'mo')
plt.title('SOH',fontsize = 40)
plt.xticks(fontsize = 40)
plt.yticks(fontsize = 40)
plt.xlabel('Time Step',fontsize = 40)
plt.ylabel('SOH' , fontsize = 40)

'''
